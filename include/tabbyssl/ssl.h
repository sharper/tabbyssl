#ifndef TABBL_SSL_H_
#define TABBL_SSL_H_

/* Warning, this file is autogenerated by cbindgen. Don't modify it. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#define SSL_ERROR -1

#define SSL_FAILURE 0

#define SSL_SUCCESS 1

#define CRYPTO_FAILURE 0

#define CRYPTO_SUCCESS 1

/*
 A structure used for the implementation of new BIO types
 */
typedef enum BIO_METHOD {
  File,
  Mem,
  Unspecified,
} BIO_METHOD;

typedef struct Arc_SSL_CTX Arc_SSL_CTX;

/*
 An I/O abstraction, it hides many of the underlying I/O details from an
 application.
 */
typedef struct BIO BIO;

/*
 An OpenSSL Cipher object
 */
typedef struct CIPHER CIPHER;

/*
 A structure for storing keys. Currently only RSA/ECC private keys are
 supported.
 */
typedef struct EVP_PKEY EVP_PKEY;

/*
 The main TLS structure which is created by a server or client per
 established connection.

 Pass a valid `SSL_CTX` object to `SSL_new` to create a new `SSL` object.
 Then associate a valid socket file descriptor with `SSL_set_fd`.
 */
typedef struct SSL SSL;

/*
 A dispatch structure describing the internal ssl library methods/functions
 which implement the various protocol versions such as TLS v1.2.

 This is a structure describing a specific TLS protocol version. It can be
 created with a method like `TLSv1_2_client_method`. Then `SSL_CTX_new` can
 consume it and create a new context. Note that a `SSL_METHOD` object is
 implicitly freed in `SSL_CTX_new`. To avoid double free, do NOT reuse
 `SSL_METHOD` objects; always create new ones when needed.
 */
typedef struct SSL_METHOD SSL_METHOD;

/*
 An OpenSSL STACK_OF(X509) object
 */
typedef struct STACK_X509 STACK_X509;

/*
 An OpenSSL STACK_OF(X509_NAME) object
 */
typedef struct STACK_X509_NAME STACK_X509_NAME;

/*
 An OpenSSL X509 object
 */
typedef struct X509 X509;

/*
 An OpenSSL X509_NAME object
 */
typedef struct X509_NAME X509_NAME;

typedef struct Arc_SSL_CTX SSL_CTX;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 `ERR_load_error_strings` - compatibility only

 ```c
 #include <tabbyssl/openssl/err.h>

 void ERR_load_error_strings(void);
 ```
 */
void ERR_load_error_strings(void);

/*
 `ERR_free_error_strings` - compatibility only

 ```c
 #include <tabbyssl/openssl/err.h>

 void SSL_free_error_strings(void);
 ```
 */
void ERR_free_error_strings(void);

/*
 `ERR_clear_error` - empty the current thread's error queue.

 ```c
 #include <tabbyssl/openssl/err.h>

 void ERR_clear_error(void);
 ```
 */
void ERR_clear_error(void);

/*
 `ERR_print_errors_fp` - a convenience function that prints the error
 strings for all errors that OpenSSL has recorded to `fp`, thus emptying the
 error queue.

 ```c
 #include <tabbyssl/openssl/err.h>

 void ERR_print_errors_fp(FILE *fp);
 ```

 # Safety
 This API is Rust-unsafe because it dereferences a pointer provided by users
 Use with caution!
 */
void ERR_print_errors_fp(FILE *fp);

/*
 For OpenSSL compatibility only. Always returns 1.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_library_init(void);
 int OpenSSL_add_ssl_algorithms(void);
 ```
 */
int SSL_library_init(void);

/*
 For OpenSSL compatibility only. Always returns 1.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_library_init(void);
 int OpenSSL_add_ssl_algorithms(void);
 ```
 */
int OpenSSL_add_ssl_algorithms(void);

/*
 For OpenSSL compatibility only.

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_load_error_strings(void);
 ```
 */
void SSL_load_error_strings(void);

/*
 `SSL_init_logger` turns on debugging output

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_load_error_strings(void);
 ```
 */
void SSL_init_logger(void);

/*
 A general-purpose version-flexible SSL/TLS method. The supported protocols
 are TLSv1.2 and TLSv1.3.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLS_method(void);
 ```

 */
const struct SSL_METHOD *TLS_method(void);

/*
 A general-purpose version-flexible SSL/TLS method. The supported protocols
 are TLSv1.2 and TLSv1.3.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLS_client_method(void);
 ```

 */
const struct SSL_METHOD *TLS_client_method(void);

/*
 A general-purpose version-flexible SSL/TLS method. The supported protocols
 are TLSv1.2 and TLSv1.3.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *SSLv23_client_method(void);
 ```

 */
const struct SSL_METHOD *SSLv23_client_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *SSLv3_client_method(void);
 ```

 */
const struct SSL_METHOD *SSLv3_client_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_client_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_client_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_1_client_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_1_client_method(void);

/*
 Version-specific method APIs. A TLS/SSL connection established with these
 methods will only understand the TLSv1.2 protocol.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_2_client_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_2_client_method(void);

/*
 Version-specific method APIs. A TLS/SSL connection established with these
 methods will only understand the TLSv1.3 protocol.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_3_client_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_3_client_method(void);

/*
 A general-purpose version-flexible SSL/TLS method. The supported protocols
 are TLSv1.2 and TLSv1.3.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLS_server_method(void);
 ```

 */
const struct SSL_METHOD *TLS_server_method(void);

/*
 A general-purpose version-flexible SSL/TLS method. The supported protocols
 are TLSv1.2 and TLSv1.3.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *SSLv23_client_method(void);
 ```

 */
const struct SSL_METHOD *SSLv23_server_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *SSLv3_server_method(void);
 ```

 */
const struct SSL_METHOD *SSLv3_server_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_server_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_server_method(void);

/*
 This SSL/TLS version is not supported. Always return NULL.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_1_server_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_1_server_method(void);

/*
 Version-specific method APIs. A TLS/SSL connection established with these
 methods will only understand the TLSv1.2 protocol.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_2_server_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_2_server_method(void);

/*
 Version-specific method APIs. A TLS/SSL connection established with these
 methods will only understand the TLSv1.3 protocol.

 ```c
 #include <mesalink/openssl/ssl.h>

 const SSL_METHOD *TLSv1_3_server_method(void);
 ```

 */
const struct SSL_METHOD *TLSv1_3_server_method(void);

/*
 `SSL_CTX_new` - create a new SSL_CTX object as framework to establish TLS/SSL
 enabled connections.

 ```c
 #include <mesalink/openssl/ssl.h>

 SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);
 ```
 */
SSL_CTX *SSL_CTX_new(const struct SSL_METHOD *method_ptr);

/*
 `SSL_CTX_load_verify_locations` - specifies the locations for ctx, at which
 CA certificates for verification purposes are located. The certificates
 available via CAfile and CApath are trusted.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
                                   const char *CApath);
 ```
 */
int SSL_CTX_load_verify_locations(SSL_CTX *ctx_ptr,
                                  const char *cafile_ptr,
                                  const char *capath_ptr);

/*
 `SSL_CTX_use_certificate_chain_file` - load a certificate chain from file
 into ctx. The certificates must be in PEM format and must be sorted starting
 with the subject's certificate (actual client or server certificate),
 followed by intermediate CA certificates if applicable, and ending at the
 highest level (root) CA.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
 ```
 */
int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx_ptr,
                                       const char *filename_ptr,
                                       int _format);

/*
 `SSL_CTX_use_certificate` loads the certificate x into ctx. The rest of the
 certificates needed to form the complete certificate chain can be specified
 using the `SSL_CTX_add_extra_chain_cert` function.
 */
int SSL_CTX_use_certificate(SSL_CTX *ctx_ptr, struct X509 *x509_ptr);

int SSL_CTX_add_extra_chain_cert(SSL_CTX *ctx_ptr, struct X509 *x509_ptr);

/*
 `SSL_CTX_use_certificate_ASN1` - load the ASN1 encoded certificate
 into ssl_ctx.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);
 ```
 */
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx_ptr, int len, unsigned char *d);

/*
 `SSL_use_certificate_ASN1` - load the ASN1 encoded certificate
 into ssl.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);
 ```
 */
int SSL_use_certificate_ASN1(struct SSL *ssl_ptr, unsigned char *d, int len);

/*
 `SSL_CTX_use_PrivateKey` adds *pkey* as private key to *ctx*

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
 ```
 */
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx_ptr, struct EVP_PKEY *pkey_ptr);

/*
 `SSL_CTX_use_PrivateKey_file` - add the first private key found in file to
 ctx. The formatting type of the certificate must be specified from the known
 types SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 ```
 */
int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx_ptr,
                                const char *filename_ptr,
                                int _format);

/*
 `SSL_CTX_use_PrivateKey_ASN1` - load the ASN1 encoded certificate into
 ssl_ctx.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,
                               long len);
 ```
 */
int SSL_CTX_use_PrivateKey_ASN1(int pk_type,
                                SSL_CTX *ctx_ptr,
                                unsigned char *d,
                                long len);

/*
 `SSL_use_PrivateKey_ASN1` - load the ASN1 encoded certificate into
 ssl.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,
                             long len);
 ```
 */
int SSL_use_PrivateKey_ASN1(int pk_type,
                            struct SSL *ssl_ptr,
                            unsigned char *d,
                            long len);

/*
 `SSL_CTX_check_private_key` - check the consistency of a private key with the
 corresponding certificate loaded into ctx

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_check_private_key(const SSL_CTX *ctx);
 ```
 */
int SSL_CTX_check_private_key(SSL_CTX *ctx_ptr);

/*
 `SSL_check_private_key` - check the consistency of a private key with the
 corresponding certificate loaded into ssl

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_check_private_key(const SSL *ssl);
 ```
 */
int SSL_check_private_key(struct SSL *ctx_ptr);

/*
 `SSL_CTX_set_verify` sets the verification flags for ctx to be *mode* and
 The verify_callback function is ignored for now.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_CTX_set_verify(const SSL_CTX *ctx, int mode, void *ignored_cb);
 ```
 */
int SSL_CTX_set_verify(SSL_CTX *ctx_ptr, int mode, int (*_cb)(int, void*));

/*
 `SSL_CTX_set_session_cache_mode` - enable/disable session caching by setting
 the operational mode for ctx to <mode>

 ```c
 #include <mesalink/openssl/ssl.h>

 long SSL_CTX_set_session_cache_mode(SSL_CTX ctx, long mode);
 ```
 */
long SSL_CTX_set_session_cache_mode(SSL_CTX *ctx_ptr, long mode);

/*
 `SSL_CTX_get_session_cache_mode` -  return the currently used cache mode

 ```c
 #include <mesalink/openssl/ssl.h>

 long SSL_CTX_get_session_cache_mode(SSL_CTX ctx);
 ```
 */
long SSL_CTX_get_session_cache_mode(SSL_CTX *ctx_ptr);

/*
 `SSL_CTX_sess_set_cache_size` -  return the currently session cache size

 ```c
 #include <mesalink/openssl/ssl.h>

 long SSL_CTX_sess_set_cache_size(SSL_CTX ctx, long t);
 ```
 */
long SSL_CTX_sess_set_cache_size(SSL_CTX *ctx_ptr, long t);

/*
 `SSL_CTX_sess_get_cache_size` -  return the currently session cache size

 ```c
 #include <mesalink/openssl/ssl.h>

 long SSL_CTX_sess_get_cache_size(SSL_CTX ctx);
 ```
 */
long SSL_CTX_sess_get_cache_size(SSL_CTX *ctx_ptr);

/*
 `SSL_new` - create a new SSL structure which is needed to hold the data for a
 TLS/SSL connection

 ```c
 #include <mesalink/openssl/ssl.h>

 SSL *SSL_new(SSL_CTX *ctx);
 ```
 */
struct SSL *SSL_new(SSL_CTX *ctx_ptr);

/*
 `SSL_get_SSL_CTX` - return a pointer to the SSL_CTX object, from which ssl was
 created with SSL_new.

 ```c
 #include <mesalink/openssl/ssl.h>

 SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
 ```
 */
const SSL_CTX *SSL_get_SSL_CTX(struct SSL *ssl_ptr);

/*
 `SSL_set_SSL_CTX` - set the SSL_CTX object of an SSL object.

 ```c
 #include <mesalink/openssl/ssl.h>

 SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx);
 ```
 */
const SSL_CTX *SSL_set_SSL_CTX(struct SSL *ssl_ptr, SSL_CTX *ctx_ptr);

/*
 `SSL_get_current_cipher` - returns a pointer to an SSL_CIPHER object
 containing the description of the actually used cipher of a connection
 established with the ssl object. See SSL_CIPHER_get_name for more details.
 Note that this API allocates memory and needs to be properly freed. freed.

 ```c
 #include <mesalink/openssl/ssl.h>

 SSL_CIPHER *SSL_get_current_cipher(const SSL *ssl);
 ```
 */
struct CIPHER *SSL_get_current_cipher(struct SSL *ssl_ptr);

#if defined(DEFINE_ERRORSTRINGS)
/*
 `SSL_CIPHER_get_name` - return a pointer to the name of cipher. If the
 argument is the NULL pointer, a pointer to the constant value "NONE" is
 returned.

 ```c
 #include <mesalink/openssl/ssl.h>

 const char *SSL_CIPHER_get_name(const SSL_CIPHER *cipher);
 ```
 */
const char *SSL_CIPHER_get_name(struct CIPHER *cipher_ptr);
#endif

#if !defined(DEFINE_ERRORSTRINGS)
const char *SSL_CIPHER_get_name(struct CIPHER *cipher_ptr);
#endif

/*
 `SSL_CIPHER_get_version` - returns string which indicates the SSL/TLS protocol
 version that first defined the cipher. This is currently SSLv2 or
 TLSv1/SSLv3. In some cases it should possibly return "TLSv1.2" but does not;
 use SSL_CIPHER_description() instead. If cipher is NULL, "(NONE)" is
 returned.

 ```c
 #include <mesalink/openssl/ssl.h>

 char *SSL_CIPHER_get_version(const SSL_CIPHER *cipher);
 ```
 */
const char *SSL_CIPHER_get_version(struct CIPHER *cipher_ptr);

/*
 `SSL_get_cipher_name` - obtain the name of the currently used cipher.

 ```c
 #include <mesalink/openssl/ssl.h>

 char *SSL_get_cipher_name(const SSL *ssl);
 ```
 */
const char *SSL_get_cipher_name(struct SSL *ssl_ptr);

/*
 `SSL_get_cipher` - obtain the name of the currently used cipher.

 ```c
 #include <mesalink/openssl/ssl.h>

 char *SSL_get_cipher(const SSL *ssl);
 ```c
 */
const char *SSL_get_cipher(struct SSL *ssl_ptr);

/*
 `SSL_get_cipher_version` - returns the protocol name.

 ```c
 #include <mesalink/openssl/ssl.h>

 char* SSL_get_cipher_version(const SSL *ssl);
 ```
 */
const char *SSL_get_cipher_version(struct SSL *ssl_ptr);

/*
 `SSL_get_peer_certificate` - get the X509 certificate of the peer

 ```c
  #include <openssl/ssl.h>

 X509 *SSL_get_peer_certificate(const SSL *ssl);
 ```
 */
struct X509 *SSL_get_peer_certificate(struct SSL *ssl_ptr);

/*
 `SSL_get_peer_certificates` - get the X509 certificate chain of the peer

 ```c
  #include <openssl/ssl.h>

 STACK_OF(X509) *SSL_get_peer_certificates(const SSL *ssl);
 ```
 */
struct STACK_X509 *SSL_get_peer_certificates(struct SSL *ssl_ptr);

/*
 `SSL_set_tlsext_host_name` - set the server name indication ClientHello
 extension to contain the value name.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_set_tlsext_host_name(const SSL *s, const char *name);
 ```
 */
int SSL_set_tlsext_host_name(struct SSL *ssl_ptr, const char *hostname_ptr);

/*
 `SSL_set_fd` - set the file descriptor fd as the input/output facility for the
 TLS/SSL (encrypted) side of ssl. fd will typically be the socket file
 descriptor of a network connection.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_set_fd(SSL *ssl, int fd);
 ```
 */
int SSL_set_fd(struct SSL *ssl_ptr, int fd);

/*
 `SSL_get_fd` - return the file descriptor which is linked to ssl.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_get_fd(const SSL *ssl);
 ```
 */
int SSL_get_fd(struct SSL *ssl_ptr);

#if defined(_WIN64)
/*
 `SSL_set_socket` - set the Windows raw socket as the input/output facility for the
 TLS/SSL (encrypted) side of ssl. fd will typically be the socket file
 descriptor of a network connection.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_set_socket(SSL *ssl, int fd);
 ```
 */
int SSL_set_socket(struct SSL *ssl_ptr,
                   int sock);
#endif

#if defined(_WIN64)
/*
 `SSL_get_socket` - return the socket which is linked to ssl.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_get_socket(const SSL *ssl);
 ```
 */
int SSL_get_socket(struct SSL *ssl_ptr);
#endif

/*
 `SSL_set_connect_state` sets *ssl* to work in client mode.

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_set_connect_state(SSL *ssl);
 ```
 */
void SSL_set_connect_state(struct SSL *ssl_ptr);

/*
 `SSL_set_accept_state` sets *ssl* to work in server mode.

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_set_accept_state(SSL *ssl);
 ```
 */
void SSL_set_accept_state(struct SSL *ssl_ptr);

/*
 `SSL_is_server` checks if ssl is working in server mode.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_is_server(SSL *ssl);
 ```
 */
int SSL_is_server(struct SSL *ssl_ptr);

/*
 `SSL_do_handshake` - perform a TLS/SSL handshake

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_do_handshake(SSL *ssl);
 ```
 */
int SSL_do_handshake(struct SSL *ssl_ptr);

/*
 `SSL_connect` - initiate the TLS handshake with a server. The communication
 channel must already have been set and assigned to the ssl with SSL_set_fd.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_connect(SSL *ssl);
 ```
 */
int SSL_connect(struct SSL *ssl_ptr);

/*
 `SSL_accept` - wait for a TLS client to initiate the TLS handshake. The
 communication channel must already have been set and assigned to the ssl by
 setting SSL_set_fd.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_accept(SSL *ssl);
 ```
 */
int SSL_accept(struct SSL *ssl_ptr);

/*
 `SSL_get_error` - obtain result code for TLS/SSL I/O operation

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_get_error(const SSL *ssl, int ret);
 ```
 */
int SSL_get_error(struct SSL *ssl_ptr, int ret);

/*
 `SSL_read` - read `num` bytes from the specified `ssl` into the
 buffer `buf`.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_read(SSL *ssl, void *buf, int num);
 ```
 */
int SSL_read(struct SSL *ssl_ptr, void *buf_ptr, int buf_len);

/*
 `SSL_write` - write `num` bytes from the buffer `buf` into the
 specified `ssl` connection.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_write(SSL *ssl, const void *buf, int num);
 ```
 */
int SSL_write(struct SSL *ssl_ptr, const void *buf_ptr, int buf_len);

/*
 `SSL_write` - write `num` bytes from the buffer `buf` into the
 specified `ssl` connection.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_write(SSL *ssl, const void *buf, int num);
 ```
 */
int SSL_flush(struct SSL *ssl_ptr);

/*
 `SSL_write_early_data` - write `num` bytes of TLS 1.3 early data from the
 buffer `buf` into the specified `ssl` connection.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_write_early_data(SSL *s, const void *buf, size_t num, size_t *written);
 ```
 */
int SSL_write_early_data(struct SSL *ssl_ptr,
                         const unsigned char *buf_ptr,
                         int buf_len,
                         size_t *written_len_ptr);

/*
 `SSL_get_early_data_status` - returns SSL_EARLY_DATA_ACCEPTED if early data
 was accepted by the server, SSL_EARLY_DATA_REJECTED if early data was
 rejected by the server.

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_get_early_data_status(const SSL *s);
 ```
 */
int SSL_get_early_data_status(struct SSL *ssl_ptr);

/*
 `SSL_shutdown` - shut down a TLS connection

 ```c
 #include <mesalink/openssl/ssl.h>

 int SSL_shutdown(SSL *ssl);
 ```
 */
int SSL_shutdown(struct SSL *ssl_ptr);

/*
 `SSL_get_version` - get the protocol information of a connection

 ```c
 #include <mesalink/openssl/ssl.h>

 const char *SSL_get_version(const SSL *ssl);
 ```
 */
const char *SSL_get_version(struct SSL *ssl_ptr);

/*
 `SSL_CTX_free` - free an allocated SSL_CTX object

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_CTX_free(SSL_CTX *ctx);
 ```c
 */
void SSL_CTX_free(SSL_CTX *ctx_ptr);

/*
 `SSL_free` - free an allocated SSL object

 ```c
 #include <mesalink/openssl/ssl.h>

 void SSL_free(SSL *ssl);
 ```c
 */
void SSL_free(struct SSL *ssl_ptr);

/*
 `X509_free` - free up a X509 structure. If a is NULL nothing is done.

 ```c
 #include <tabbyssl/openssl/x509.h>

 void X509_free(X509 *a);
 ```
 */
void X509_free(struct X509 *x509_ptr);

/*
 `X509_NAME_free` - free up a X509_NAME structure. If a is NULL nothing is
 done.

 ```c
 #include <tabbyssl/openssl/x509.h>

 void X509_free(X509 *a);
 ```
 */
void X509_NAME_free(struct X509_NAME *x509_name_ptr);

/*
 `X509_get_alt_subject_names` - returns the alternative subject names of
 certificate x. The returned value is a STACK pointer which MUST be freed by
 `sk_X509_NAME_free`.

 ```c
 #include <tabbyssl/openssl/x509.h>

 STACK_OF(X509_NAME) *X509_get_alt_subject_names(const X509 *x);;
 ```
 */
struct STACK_X509_NAME *X509_get_alt_subject_names(struct X509 *x509_ptr);

/*
 `X509_get_subject` - returns the DER bytes of the subject of x as a
 `X509_NAME`. The returned value is a X509_NAME pointer which MUST be freed
 by `X509_NAME_free`.

 ```c
 #include <tabbyssl/openssl/x509.h>

 X509_NAME *X509_get_subject(const X509 *x);;
 ```
 */
struct X509_NAME *X509_get_subject(struct X509 *x509_ptr);

/*
 `X509_get_subject_name` - returns the subject of x as a human readable
 `X509_NAME`. The returned value is a X509_NAME pointer which MUST be freed
 by `X509_NAME_free`.

 ```c
 #include <tabbyssl/openssl/x509.h>

 X509_NAME *X509_get_subject_name(const X509 *x);;
 ```
 */
struct X509_NAME *X509_get_subject_name(struct X509 *x509_ptr);

/*
 `X509_NAME_oneline` - prints an ASCII version of a to buf. If buf is NULL
 then a buffer is dynamically allocated and returned, and size is ignored.
 Otherwise, at most size bytes will be written, including the ending '\0',
 and buf is returned.

 ```c
 #include <tabbyssl/openssl/x509.h>

 char * X509_NAME_oneline(X509_NAME *a,char *buf,int size);
 ```
 */
char *X509_NAME_oneline(struct X509_NAME *x509_name_ptr,
                        char *buf_ptr,
                        int size);

/*
 `sk_X509_new_null` - allocates a new stack of X509.

 ```c
 #include <tabbyssl/openssl/x509.h>

 STACK_OF(X509) *sk_X509_new_null(void);
 ```
 */
struct STACK_X509 *sk_X509_new_null(void);

/*
 `sk_X509_num` - returns the number of elements in sk or -1 if sk is NULL.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 int sk_X509_num(const STACK_OF(X509) *sk);
 ```
 */
int sk_X509_num(const struct STACK_X509 *stack_ptr);

/*
 `sk_X509_value` - returns element idx in sk, where idx starts at zero. If
 idx is out of range then NULL is returned.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 X509 *sk_X509_value(const STACK_OF(X509) *sk, int idx);
 ```
 */
const struct X509 *sk_X509_value(const struct STACK_X509 *stack_ptr, int index);

/*
 `sk_X509_push` - appends ptr to sk.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 int sk_X509_push(STACK_OF(X509) *sk, const X509 *ptr);
 ```
 */
int sk_X509_push(struct STACK_X509 *stack_ptr, const struct X509 *item_ptr);

/*
 `sk_X509_free` - frees up the sk structure. After this call sk is no longer
 valid.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 void sk_X509_free(const STACK_OF(X509) *sk);
 ```
 */
void sk_X509_free(struct STACK_X509 *stack_ptr);

/*
 `sk_X509_NAME_new_null` - allocates a new stack of X509_NAME.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 STACK_OF(X509_NAME) *sk_X509_NAME_new_null(void);
 ```
 */
struct STACK_X509_NAME *sk_X509_NAME_new_null(void);

/*
 `sk_X509_NAME_num` - returns the number of elements in sk or -1 if sk is NULL..

 ```c
 #include <tabbyssl/openssl/safestack.h>

 int sk_X509_NAME_num(const STACK_OF(X509_NAME) *sk);
 ```
 */
int sk_X509_NAME_num(const struct STACK_X509_NAME *stack_ptr);

/*
 `sk_X509_NAME_value` - returns element idx in sk, where idx starts at zero.
 If idx is out of range then NULL is returned.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 X509_NAME *sk_X509_NAME_value(const STACK_OF(X509_NAME) *sk, int idx);
 ```
 */
const struct X509_NAME *sk_X509_NAME_value(const struct STACK_X509_NAME *stack_ptr,
                                           int index);

/*
 `sk_X509_NAME_push` - appends ptr to sk.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 int sk_X509_NAME_push(STACK_OF(X509_NAME) *sk, const X509_NAME *ptr);
 ```
 */
int sk_X509_NAME_push(struct STACK_X509_NAME *stack_ptr,
                      const struct X509_NAME *item_ptr);

/*
 `sk_X509_NAME_free` - frees up the sk structure. After this call sk is no longer
 valid.

 ```c
 #include <tabbyssl/openssl/safestack.h>

 void sk_X509_NAME_free(const STACK_OF(X509_NAME) *sk);
 ```
 */
void sk_X509_NAME_free(struct STACK_X509_NAME *stack_ptr);

/*
 `BIO_new()` returns a new BIO using method `type`

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_new(BIO_METHOD *type);
 ```
 */
struct BIO *BIO_new(const enum BIO_METHOD *method_ptr);

/*
 `BIO_free()` frees a BIO

 ```c
 #include <tabbyssl/openssl/bio.h>

 int BIO_free(BIO *a);
 ```
 */
void BIO_free(struct BIO *bio_ptr);

/*
 `BIO_read` attempts to read *len* bytes from BIO *b* and places the data in
 *buf*。

 ```c
 #include <openssl/bio.h>

 int BIO_read(BIO *b, void *buf, int len);
 ```
 */
int BIO_read(struct BIO *bio_ptr, void *buf_ptr, int len);

/*
 `BIO_gets` attempts to read a line of data from the BIO *b* of maximum
 length *len* and places teh data in *buf*.
 ```c
 #include <openssl/bio.h>

 int BIO_gets(BIO *b, char *buf, int size);
 ```
 */
int BIO_gets(struct BIO *bio_ptr, char *buf_ptr, int size);

/*
 `BIO_write` attempts to write *len* bytes from *buf* to BIO *b*.

 ```c
 #include <openssl/bio.h>

 int BIO_write(BIO *b, void *buf, int len);
 ```
 */
int BIO_write(struct BIO *bio_ptr, const void *buf_ptr, int len);

/*
 `BIO_puts` attempts to write a null terminated string *buf* to BIO *b*.

 ```c
 #include <openssl/bio.h>

 int BIO_puts(BIO *b, const char *buf);
 ```
 */
int BIO_puts(struct BIO *bio_ptr, const char *buf_ptr);

/*
 `BIO_s_file()` returns the BIO file method.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO_METHOD *BIO_s_file(void);
 ```
 */
const enum BIO_METHOD *BIO_s_file(void);

/*
 `BIO_new_file()` creates a new file BIO with mode mode the meaning of mode
 is the same as the stdio function fopen(). The BIO_CLOSE flag is set on the
 returned BIO.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_new_file(const char *filename, const char *mode);
 ```
 */
struct BIO *BIO_new_file(const char *filename_ptr, const char *mode_ptr);

/*
 `BIO_read_filename()` sets the file BIO b to use file name for reading.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_read_file(const char *filename);
 ```
 */
int BIO_read_filename(struct BIO *bio_ptr, const char *filename_ptr);

/*
 `BIO_write_filename()` sets the file BIO b to use file name for writing.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_write_file(const char *filename);
 ```
 */
int BIO_write_filename(struct BIO *bio_ptr, const char *filename_ptr);

/*
 `BIO_append_filename()` sets the file BIO b to use file name for appending.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_append_filename(const char *filename);
 ```
 */
int BIO_append_filename(struct BIO *bio_ptr, const char *filename_ptr);

/*
 `BIO_rw_filename()` sets the file BIO b to use file name for reading and
 writing.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_rw_file(const char *filename);
 ```
 */
int BIO_rw_filename(struct BIO *bio_ptr, const char *filename_ptr);

/*
 `BIO_new_fp()` screates a file BIO wrapping `stream`

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_new_fp(FILE *stream, int flags);
 ```
 */
struct BIO *BIO_new_fp(FILE *stream, int flags);

/*
 `BIO_set_fp()` sets the fp of a file BIO to `fp`.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO_set_fp(BIO *b,FILE *fp, int flags);
 ```
 */
void BIO_set_fp(struct BIO *bio_ptr, FILE *fp, int flags);

/*
 `BIO_get_close()` returns the BIOs close flag.

 ```c
 #include <tabbyssl/openssl/bio.h>

 int BIO_get_close(BIO *b);
 ```
 */
int BIO_get_close(struct BIO *bio_ptr);

/*
 `BIO_set_close()` sets the BIO *b* close flag to *flag*

 ```c
 #include <tabbyssl/openssl/bio.h>

 int BIO_set_close(BIO *b, long flag);
 ```
 */
int BIO_set_close(struct BIO *bio_ptr, long flag);

/*
 `BIO_s_file()` returns the BIO memory method.

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO_METHOD *BIO_s_mem(void);
 ```
 */
const enum BIO_METHOD *BIO_s_mem(void);

/*
 `BIO_new_mem_buf()` creates a memory BIO using `len` bytes of data at `buf`

 ```c
 #include <tabbyssl/openssl/bio.h>

 BIO *BIO_new_mem_buf(const void *buf, int len);
 ```
 */
struct BIO *BIO_new_mem_buf(void *buf_ptr, int len);

/*
 `EVP_PKEY_free()` frees a EVP_PKEY

 ```c
 #include <tabbyssl/openssl/evp.h>

 int EVP_PKEY_free(EVP_PKEY *p);
 ```
 */
void EVP_PKEY_free(struct EVP_PKEY *pkey_ptr);

/*
 `PEM_read_bio_PrivateKey` reads a private key from *bio*. If there are
 multiple keys in the bio, only the first one is read.

 ```c
 #include <tabbyssl/openssl/pem.h>

 EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bio, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
 ```

 */
struct EVP_PKEY *PEM_read_bio_PrivateKey(struct BIO *bio_ptr,
                                         struct EVP_PKEY **pkey_pp,
                                         void *_cb,
                                         void *_u);

/*
 `PEM_read_PrivateKey` reads a private key from *file*. If there are multiple
 keys in the file, only the first one is read.

 ```c
 #include <tabbyssl/openssl/pem.h>

 EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                     pem_password_cb *cb, void *u);
 ```
 */
struct EVP_PKEY *PEM_read_PrivateKey(FILE *file_ptr,
                                     struct EVP_PKEY **pkey_pp,
                                     void *_cb,
                                     void *_u);

/*
 `PEM_read_bio_X509` reads a X509 certificate from *bio*. If there are
 multiple certificates in the bio, only the first one is read.

 ```c
 #include <tabbyssl/openssl/pem.h>

 X509 *PEM_read_bio_X509(BIO *bio, X509 **x, pem_password_cb *cb, void *u);
 ```
 */
struct X509 *PEM_read_bio_X509(struct BIO *bio_ptr,
                               struct X509 **x509_pp,
                               void *_cb,
                               void *_u);

/*
 `PEM_read_X509` reads a X509 certificate from *file*.

 ```c
 #include <tabbyssl/openssl/pem.h>

 X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
 ```
 */
struct X509 *PEM_read_X509(FILE *file_ptr,
                           struct X509 **x509_pp,
                           void *_cb,
                           void *_u);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* TABBL_SSL_H_ */
